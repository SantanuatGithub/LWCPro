"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const rollup_1 = require("rollup");
const meta_collector_1 = require("./meta-collector");
const module_resolver_1 = __importDefault(require("../rollup-plugins/module-resolver"));
const env_replacement_1 = __importDefault(require("../rollup-plugins/env-replacement"));
const transform_1 = __importDefault(require("../rollup-plugins/transform"));
const compat_1 = __importDefault(require("../rollup-plugins/compat"));
const minify_1 = __importDefault(require("../rollup-plugins/minify"));
const options_1 = require("../compiler/options");
const errors_1 = require("@lwc/errors");
const DEFAULT_FORMAT = 'amd';
function handleRollupWarning(diagnostics) {
    return function onwarn({ message, loc, pos }) {
        // loc and pos are bundled together
        const origin = loc && pos
            ? {
                filename: loc.file,
                location: {
                    line: loc.line,
                    column: loc.column,
                    start: pos,
                    length: 0,
                },
            }
            : {};
        diagnostics.push(errors_1.generateCompilerDiagnostic(errors_1.ModuleResolutionErrors.MODULE_RESOLUTION_ERROR, {
            messageArgs: [message],
            origin,
        }));
    };
}
async function bundle(options) {
    options_1.validateNormalizedOptions(options);
    const { outputConfig, name, namespace } = options;
    // TODO: remove format option once tests are converted to 'amd' format
    const format = outputConfig.format || DEFAULT_FORMAT;
    const diagnostics = [];
    const metadataCollector = new meta_collector_1.MetadataCollector();
    const plugins = [
        module_resolver_1.default({
            options,
        }),
    ];
    // Run environment variable replacement first. This ensures that the source code is still untouched
    // at this point.
    if (Object.keys(outputConfig.env).length) {
        plugins.push(env_replacement_1.default({
            options,
        }));
    }
    plugins.push(transform_1.default({
        metadataCollector,
        options,
    }));
    if (outputConfig.compat) {
        plugins.push(compat_1.default(outputConfig));
    }
    if (outputConfig.minify) {
        plugins.push(minify_1.default(outputConfig));
    }
    let code;
    let map = null;
    try {
        const rollupBundler = await rollup_1.rollup({
            input: name,
            plugins,
            onwarn: handleRollupWarning(diagnostics),
        });
        const result = await rollupBundler.generate({
            amd: { id: namespace + '/' + name },
            interop: false,
            strict: false,
            sourcemap: outputConfig.sourcemap,
            format,
        });
        code = result.code;
        map = result.map;
    }
    catch (e) {
        // Rollup may have clobbered error.code with its own data
        if (e instanceof errors_1.CompilerError && e.pluginCode) {
            e.code = e.pluginCode;
        }
        const diagnostic = errors_1.normalizeToDiagnostic(errors_1.ModuleResolutionErrors.MODULE_RESOLUTION_ERROR, e);
        diagnostic.level = errors_1.DiagnosticLevel.Fatal;
        diagnostics.push(diagnostic);
    }
    return {
        diagnostics,
        code,
        map,
        metadata: metadataCollector.getMetadata(),
    };
}
exports.bundle = bundle;
//# sourceMappingURL=bundler.js.map
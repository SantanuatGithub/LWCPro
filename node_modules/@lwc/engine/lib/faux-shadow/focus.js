"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const window_1 = require("../env/window");
const element_1 = require("../env/element");
const node_1 = require("../env/node");
const language_1 = require("../shared/language");
const document_1 = require("../env/document");
const dom_1 = require("../env/dom");
const shadow_root_1 = require("./shadow-root");
const TabbableElementsQuery = `
    button:not([tabindex="-1"]):not([disabled]),
    [contenteditable]:not([tabindex="-1"]),
    video[controls]:not([tabindex="-1"]),
    audio[controls]:not([tabindex="-1"]),
    [href]:not([tabindex="-1"]),
    input:not([tabindex="-1"]):not([disabled]),
    select:not([tabindex="-1"]):not([disabled]),
    textarea:not([tabindex="-1"]):not([disabled]),
    [tabindex="0"]
`;
function isVisible(element) {
    const { width, height } = element_1.getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
}
function hasFocusableTabIndex(element) {
    if (language_1.isFalse(element_1.hasAttribute.call(element, 'tabindex'))) {
        return false;
    }
    const value = element_1.getAttribute.call(element, 'tabindex');
    // Really, any numeric tabindex value is valid
    // But LWC only allows 0 or -1, so we can just check against that.
    // The main point here is to make sure the tabindex attribute is not an invalid
    // value like tabindex="hello"
    if (value === '' || (value !== '0' && value !== '-1')) {
        return false;
    }
    return true;
}
// This function based on https://allyjs.io/data-tables/focusable.html
// It won't catch everything, but should be good enough
// There are a lot of edge cases here that we can't realistically handle
// Determines if a particular element is tabbable, as opposed to simply focusable
// Exported for jest purposes
function isTabbable(element) {
    return element_1.matches.call(element, TabbableElementsQuery) && isVisible(element);
}
exports.isTabbable = isTabbable;
const focusableTagNames = {
    IFRAME: 1,
    VIDEO: 1,
    AUDIO: 1,
    A: 1,
    INPUT: 1,
    SELECT: 1,
    TEXTAREA: 1,
    BUTTON: 1,
};
// This function based on https://allyjs.io/data-tables/focusable.html
// It won't catch everything, but should be good enough
// There are a lot of edge cases here that we can't realistically handle
// Exported for jest purposes
function isFocusable(element) {
    const tagName = element_1.tagNameGetter.call(element);
    return (isVisible(element) &&
        (hasFocusableTabIndex(element) ||
            element_1.hasAttribute.call(element, 'contenteditable') ||
            language_1.hasOwnProperty.call(focusableTagNames, tagName)));
}
exports.isFocusable = isFocusable;
function getFirstTabbableMatch(elements) {
    for (let i = 0, len = elements.length; i < len; i += 1) {
        const elm = elements[i];
        if (isTabbable(elm)) {
            return elm;
        }
    }
    return null;
}
function getLastTabbableMatch(elements) {
    for (let i = elements.length - 1; i >= 0; i -= 1) {
        const elm = elements[i];
        if (isTabbable(elm)) {
            return elm;
        }
    }
    return null;
}
function getTabbableSegments(host) {
    const all = document_1.querySelectorAll.call(document, TabbableElementsQuery);
    const inner = language_1.ArraySlice.call(element_1.querySelectorAll.call(host, TabbableElementsQuery));
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(element_1.tabIndexGetter.call(host) === -1 || shadow_root_1.isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
    }
    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = language_1.ArrayIndexOf.call(all, host);
    // Host element can show up in our "previous" section if its tabindex is 0
    // We want to filter that out here
    const firstChildIndex = hostIndex > -1 ? hostIndex : language_1.ArrayIndexOf.call(all, firstChild);
    // Account for an empty inner list
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : language_1.ArrayIndexOf.call(all, lastChild) + 1;
    const prev = language_1.ArraySlice.call(all, 0, firstChildIndex);
    const next = language_1.ArraySlice.call(all, lastChildIndex);
    return {
        prev,
        inner,
        next,
    };
}
function getActiveElement(host) {
    const activeElement = document_1.DocumentPrototypeActiveElement.call(document);
    if (language_1.isNull(activeElement)) {
        return activeElement;
    }
    // activeElement must be child of the host and owned by it
    return (node_1.compareDocumentPosition.call(host, activeElement) & node_1.DOCUMENT_POSITION_CONTAINED_BY) !==
        0
        ? activeElement
        : null;
}
exports.getActiveElement = getActiveElement;
function relatedTargetPosition(host, relatedTarget) {
    // assert: target must be child of host
    const pos = node_1.compareDocumentPosition.call(host, relatedTarget);
    if (pos & node_1.DOCUMENT_POSITION_CONTAINED_BY) {
        // focus remains inside the host
        return 0;
    }
    else if (pos & node_1.DOCUMENT_POSITION_PRECEDING) {
        // focus is coming from above
        return 1;
    }
    else if (pos & node_1.DOCUMENT_POSITION_FOLLOWING) {
        // focus is coming from below
        return 2;
    }
    // we don't know what's going on.
    return -1;
}
function getPreviousTabbableElement(segments) {
    const { prev } = segments;
    return getFirstTabbableMatch(language_1.ArrayReverse.call(prev));
}
function getNextTabbableElement(segments) {
    const { next } = segments;
    return getFirstTabbableMatch(next);
}
function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
}
function muteFocusEventsDuringExecution(func) {
    window_1.windowAddEventListener.call(window, 'focusin', muteEvent, true);
    window_1.windowAddEventListener.call(window, 'focusout', muteEvent, true);
    func();
    window_1.windowRemoveEventListener.call(window, 'focusin', muteEvent, true);
    window_1.windowRemoveEventListener.call(window, 'focusout', muteEvent, true);
}
function focusOnNextOrBlur(focusEventTarget, segments) {
    muteFocusEventsDuringExecution(() => {
        const nextNode = getNextTabbableElement(segments);
        if (language_1.isNull(nextNode)) {
            // nothing to focus on, blur to invalidate the operation
            focusEventTarget.blur();
        }
        else {
            nextNode.focus();
        }
    });
}
function focusOnPrevOrBlur(focusEventTarget, segments) {
    muteFocusEventsDuringExecution(() => {
        const prevNode = getPreviousTabbableElement(segments);
        if (language_1.isNull(prevNode)) {
            // nothing to focus on, blur to invalidate the operation
            focusEventTarget.blur();
        }
        else {
            prevNode.focus();
        }
    });
}
function isFirstTabbableChild(target, segments) {
    return getFirstTabbableMatch(segments.inner) === target;
}
function isLastTabbableChild(target, segments) {
    return getLastTabbableMatch(segments.inner) === target;
}
function keyboardFocusHandler(event) {
    const host = dom_1.eventCurrentTargetGetter.call(event);
    const target = dom_1.eventTargetGetter.call(event);
    // Ideally, we would be able to use a "focus" event that doesn't bubble
    // but, IE11 doesn't support relatedTarget on focus events so we have to use
    // focusin instead. The logic below is predicated on non-bubbling events
    // So, if currentTarget(host) ir not target, we know that the event is bubbling
    // and we escape because focus occured on something below the host.
    if (host !== target) {
        return;
    }
    const relatedTarget = dom_1.focusEventRelatedTargetGetter.call(event);
    if (language_1.isNull(relatedTarget)) {
        return;
    }
    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);
    if (position === 1) {
        // probably tabbing into element
        const first = getFirstTabbableMatch(segments.inner);
        if (!language_1.isNull(first)) {
            muteFocusEventsDuringExecution(() => {
                first.focus();
            });
        }
        else {
            focusOnNextOrBlur(target, segments);
        }
    }
    else if (host === target) {
        // Shift tabbed back to the host
        focusOnPrevOrBlur(host, segments);
    }
}
// focusin handler for custom elements
// This handler should only be called when a user
// focuses on either the custom element, or an internal element
// via keyboard navigation (tab or shift+tab)
// Focusing via mouse should be disqualified before this gets called
function keyboardFocusInHandler(event) {
    const host = dom_1.eventCurrentTargetGetter.call(event);
    const target = dom_1.eventTargetGetter.call(event);
    const relatedTarget = dom_1.focusEventRelatedTargetGetter.call(event);
    const segments = getTabbableSegments(host);
    const isFirstFocusableChildReceivingFocus = isFirstTabbableChild(target, segments);
    const isLastFocusableChildReceivingFocus = isLastTabbableChild(target, segments);
    if (
    // If we receive a focusin event that is not focusing on the first or last
    // element inside of a shadow, we can assume that the user is tabbing between
    // elements inside of the custom element shadow, so we do nothing
    (language_1.isFalse(isFirstFocusableChildReceivingFocus) &&
        language_1.isFalse(isLastFocusableChildReceivingFocus)) ||
        // If related target is null, user is probably tabbing into the document from the browser chrome (location bar?)
        // If relatedTarget is null, we can't do much here because we don't know what direction the user is tabbing
        // This is a bit of an edge case, and only comes up if the custom element is the very first or very last
        // tabbable element in a document
        language_1.isNull(relatedTarget)) {
        return;
    }
    // Determine where the focus is coming from (Tab or Shift+Tab)
    const post = relatedTargetPosition(host, relatedTarget);
    switch (post) {
        case 1: // focus is probably coming from above
            if (isFirstFocusableChildReceivingFocus) {
                // the focus was on the immediate focusable elements from above,
                // it is almost certain that the focus is due to tab keypress
                focusOnNextOrBlur(target, segments);
            }
            break;
        case 2: // focus is probably coming from below
            if (isLastFocusableChildReceivingFocus) {
                // the focus was on the immediate focusable elements from above,
                // it is almost certain that the focus is due to tab keypress
                focusOnPrevOrBlur(target, segments);
            }
            break;
    }
}
function willTriggerFocusInEvent(target) {
    return (target !== document_1.DocumentPrototypeActiveElement.call(document) && isFocusable(target) // if the element is currently active, it will not fire a focusin event
    );
}
function enterMouseDownState(evt) {
    const currentTarget = dom_1.eventCurrentTargetGetter.call(evt);
    element_1.removeEventListener.call(currentTarget, 'focusin', keyboardFocusInHandler);
    setTimeout(() => {
        // only reinstate the focus if the tabindex is still -1
        if (element_1.tabIndexGetter.call(currentTarget) === -1) {
            element_1.addEventListener.call(currentTarget, 'focusin', keyboardFocusInHandler);
        }
    }, 0);
}
function exitMouseDownState(event) {
    const currentTarget = dom_1.eventCurrentTargetGetter.call(event);
    const relatedTarget = dom_1.focusEventRelatedTargetGetter.call(event);
    // If the focused element is null or the focused element is no longer internal
    if (language_1.isNull(relatedTarget) ||
        relatedTargetPosition(currentTarget, relatedTarget) !== 0) {
        element_1.removeEventListener.call(currentTarget, 'focusin', enterMouseDownState, true);
        element_1.removeEventListener.call(currentTarget, 'focusout', exitMouseDownState, true);
    }
}
function handleFocusMouseDown(evt) {
    const target = dom_1.eventTargetGetter.call(evt);
    // If we are mouse down in an element that can be focused
    // and the currentTarget's activeElement is not element we are mouse-ing down in
    // We can bail out and let the browser do its thing.
    if (willTriggerFocusInEvent(target)) {
        const currentTarget = dom_1.eventCurrentTargetGetter.call(evt);
        // Enter the temporary state where we disable the keyboard focusin handler when we click into the shadow.
        element_1.addEventListener.call(currentTarget, 'focusin', enterMouseDownState, true);
        // Exit the temporary state When focus leaves the shadow.
        element_1.addEventListener.call(currentTarget, 'focusout', exitMouseDownState, true);
    }
}
function handleFocus(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(shadow_root_1.isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${language_1.toString(elm)}. ${language_1.toString(elm)} should have delegates focus true, but is not delegating focus`);
    }
    // Unbind any focusin listeners we may have going on
    ignoreFocusIn(elm);
    element_1.addEventListener.call(elm, 'focusin', keyboardFocusHandler, true);
}
exports.handleFocus = handleFocus;
function ignoreFocus(elm) {
    element_1.removeEventListener.call(elm, 'focusin', keyboardFocusHandler, true);
}
exports.ignoreFocus = ignoreFocus;
function handleFocusIn(elm) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(element_1.tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${language_1.toString(elm)}. ${language_1.toString(elm)} should have tabIndex -1, but has tabIndex ${element_1.tabIndexGetter.call(elm)}`);
    }
    // Unbind any focus listeners we may have going on
    ignoreFocus(elm);
    // We want to listen for mousedown
    // If the user is triggering a mousedown event on an element
    // That can trigger a focus event, then we need to opt out
    // of our tabindex -1 dance. The tabindex -1 only applies for keyboard navigation
    element_1.addEventListener.call(elm, 'mousedown', handleFocusMouseDown, true);
    // This focusin listener is to catch focusin events from keyboard interactions
    // A better solution would perhaps be to listen for keydown events, but
    // the keydown event happens on whatever element already has focus (or no element
    // at all in the case of the location bar. So, instead we have to assume that focusin
    // without a mousedown means keyboard navigation
    element_1.addEventListener.call(elm, 'focusin', keyboardFocusInHandler);
}
exports.handleFocusIn = handleFocusIn;
function ignoreFocusIn(elm) {
    element_1.removeEventListener.call(elm, 'focusin', keyboardFocusInHandler);
    element_1.removeEventListener.call(elm, 'mousedown', handleFocusMouseDown, true);
}
exports.ignoreFocusIn = ignoreFocusIn;
//# sourceMappingURL=focus.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const node_1 = require("./node");
const node_2 = require("../env/node");
const element_1 = require("../env/element");
const iframe_1 = require("./iframe");
const language_1 = require("../shared/language");
const language_2 = require("../shared/language");
const outer_html_1 = require("../3rdparty/polymer/outer-html");
const shadow_root_1 = require("./shadow-root");
const static_node_list_1 = require("../shared/static-node-list");
const dom_1 = require("../env/dom");
const slot_1 = require("./slot");
require("../polyfills/node-get-root-node/main");
// Extract the patched getRootNode
exports.patchedGetRootNode = Node.prototype.getRootNode;
function getNodeOwner(node) {
    if (!(node instanceof Node)) {
        return null;
    }
    const ownerKey = node_1.getNodeNearestOwnerKey(node);
    if (language_1.isUndefined(ownerKey)) {
        return null;
    }
    let nodeOwner = node;
    // At this point, node is a valid node with owner identity, now we need to find the owner node
    // search for a custom element with a VM that owns the first element with owner identity attached to it
    while (!language_2.isNull(nodeOwner) && node_1.getNodeKey(nodeOwner) !== ownerKey) {
        nodeOwner = node_2.parentNodeGetter.call(nodeOwner);
    }
    if (language_2.isNull(nodeOwner)) {
        return null;
    }
    return nodeOwner;
}
exports.getNodeOwner = getNodeOwner;
function isSlotElement(elm) {
    return element_1.tagNameGetter.call(elm) === 'SLOT';
}
exports.isSlotElement = isSlotElement;
function isNodeOwnedBy(owner, node) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
        assert_1.default.invariant(node instanceof Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
        assert_1.default.isTrue(node_2.compareDocumentPosition.call(node, owner) & node_2.DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
    }
    const ownerKey = node_1.getNodeNearestOwnerKey(node);
    return language_1.isUndefined(ownerKey) || node_1.getNodeKey(owner) === ownerKey;
}
exports.isNodeOwnedBy = isNodeOwnedBy;
// when finding a slot in the DOM, we can fold it if it is contained
// inside another slot.
function foldSlotElement(slot) {
    let parent = node_2.parentElementGetter.call(slot);
    while (!language_2.isNull(parent) && isSlotElement(parent)) {
        slot = parent;
        parent = node_2.parentElementGetter.call(slot);
    }
    return slot;
}
function isNodeSlotted(host, node) {
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
        assert_1.default.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
        assert_1.default.isTrue(node_2.compareDocumentPosition.call(node, host) & node_2.DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
    }
    const hostKey = node_1.getNodeKey(host);
    // this routine assumes that the node is coming from a different shadow (it is not owned by the host)
    // just in case the provided node is not an element
    let currentElement = node instanceof Element ? node : node_2.parentElementGetter.call(node);
    while (!language_2.isNull(currentElement) && currentElement !== host) {
        const elmOwnerKey = node_1.getNodeNearestOwnerKey(currentElement);
        const parent = node_2.parentElementGetter.call(currentElement);
        if (elmOwnerKey === hostKey) {
            // we have reached an element inside the host's template, and only if
            // that element is an slot, then the node is considered slotted
            // TODO: add the examples
            return isSlotElement(currentElement);
        }
        else if (parent === host) {
            return false;
        }
        else if (!language_2.isNull(parent) && node_1.getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
            // we are crossing a boundary of some sort since the elm and its parent
            // have different owner key. for slotted elements, this is possible
            // if the parent happens to be a slot.
            if (isSlotElement(parent)) {
                /**
                 * the slot parent might be allocated inside another slot, think of:
                 * <x-root> (<--- root element)
                 *    <x-parent> (<--- own by x-root)
                 *       <x-child> (<--- own by x-root)
                 *           <slot> (<--- own by x-child)
                 *               <slot> (<--- own by x-parent)
                 *                  <div> (<--- own by x-root)
                 *
                 * while checking if x-parent has the div slotted, we need to traverse
                 * up, but when finding the first slot, we skip that one in favor of the
                 * most outer slot parent before jumping into its corresponding host.
                 */
                currentElement = getNodeOwner(foldSlotElement(parent));
                if (!language_2.isNull(currentElement)) {
                    if (currentElement === host) {
                        // the slot element is a top level element inside the shadow
                        // of a host that was allocated into host in question
                        return true;
                    }
                    else if (node_1.getNodeNearestOwnerKey(currentElement) === hostKey) {
                        // the slot element is an element inside the shadow
                        // of a host that was allocated into host in question
                        return true;
                    }
                }
            }
            else {
                return false;
            }
        }
        else {
            currentElement = parent;
        }
    }
    return false;
}
function shadowRootChildNodes(root) {
    const elm = shadow_root_1.getHost(root);
    return getAllMatches(elm, node_2.childNodesGetter.call(elm));
}
exports.shadowRootChildNodes = shadowRootChildNodes;
function getAllMatches(owner, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        const isOwned = isNodeOwnedBy(owner, node);
        if (isOwned) {
            // Patch querySelector, querySelectorAll, etc
            // if element is owned by VM
            language_1.ArrayPush.call(filteredAndPatched, node);
        }
    }
    return filteredAndPatched;
}
exports.getAllMatches = getAllMatches;
function getFirstMatch(owner, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        if (isNodeOwnedBy(owner, nodeList[i])) {
            return nodeList[i];
        }
    }
    return null;
}
function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            language_1.ArrayPush.call(filteredAndPatched, node);
        }
    }
    return filteredAndPatched;
}
function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
        const node = nodeList[i];
        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
            return node;
        }
    }
    return null;
}
function lightDomQuerySelectorAll(elm, selectors) {
    const owner = getNodeOwner(elm);
    if (language_2.isNull(owner)) {
        return [];
    }
    const nodeList = element_1.querySelectorAll.call(elm, selectors);
    if (node_1.getNodeKey(elm)) {
        // it is a custom element, and we should then filter by slotted elements
        return getAllSlottedMatches(elm, nodeList);
    }
    else {
        // regular element, we should then filter by ownership
        return getAllMatches(owner, nodeList);
    }
}
function lightDomQuerySelector(elm, selector) {
    const owner = getNodeOwner(elm);
    if (language_2.isNull(owner)) {
        // the it is a root, and those can't have a lightdom
        return null;
    }
    const nodeList = element_1.querySelectorAll.call(elm, selector);
    if (node_1.getNodeKey(elm)) {
        // it is a custom element, and we should then filter by slotted elements
        return getFirstSlottedMatch(elm, nodeList);
    }
    else {
        // regular element, we should then filter by ownership
        return getFirstMatch(owner, nodeList);
    }
}
function shadowRootQuerySelector(root, selector) {
    const elm = shadow_root_1.getHost(root);
    const nodeList = element_1.querySelectorAll.call(elm, selector);
    return getFirstMatch(elm, nodeList);
}
exports.shadowRootQuerySelector = shadowRootQuerySelector;
function shadowRootQuerySelectorAll(root, selector) {
    const elm = shadow_root_1.getHost(root);
    const nodeList = element_1.querySelectorAll.call(elm, selector);
    return getAllMatches(elm, nodeList);
}
exports.shadowRootQuerySelectorAll = shadowRootQuerySelectorAll;
function getFilteredChildNodes(node) {
    let children;
    if (!language_1.isUndefined(node_1.getNodeKey(node))) {
        // node itself is a custom element
        // lwc element, in which case we need to get only the nodes
        // that were slotted
        const slots = element_1.querySelectorAll.call(node, 'slot');
        children = language_1.ArrayReduce.call(slots, (seed, slot) => {
            if (isNodeOwnedBy(node, slot)) {
                language_1.ArrayPush.apply(seed, slot_1.getFilteredSlotAssignedNodes(slot));
            }
            return seed;
        }, []);
    }
    else {
        // regular element
        children = node_2.childNodesGetter.call(node);
    }
    const owner = getNodeOwner(node);
    if (language_2.isNull(owner)) {
        return [];
    }
    // Typescript is inferring the wrong function type for this particular
    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
    // @ts-ignore type-mismatch
    return language_1.ArrayReduce.call(children, (seed, child) => {
        if (isNodeOwnedBy(owner, child)) {
            language_1.ArrayPush.call(seed, child);
        }
        return seed;
    }, []);
}
exports.getFilteredChildNodes = getFilteredChildNodes;
function PatchedElement(elm) {
    const Ctor = node_1.PatchedNode(elm);
    return class PatchedHTMLElement extends Ctor {
        querySelector(selector) {
            return lightDomQuerySelector(this, selector);
        }
        querySelectorAll(selectors) {
            return static_node_list_1.createStaticNodeList(lightDomQuerySelectorAll(this, selectors));
        }
        get innerHTML() {
            const childNodes = node_1.getInternalChildNodes(this);
            let innerHTML = '';
            for (let i = 0, len = childNodes.length; i < len; i += 1) {
                innerHTML += outer_html_1.getOuterHTML(childNodes[i]);
            }
            return innerHTML;
        }
        set innerHTML(value) {
            element_1.innerHTMLSetter.call(this, value);
        }
        get outerHTML() {
            return outer_html_1.getOuterHTML(this);
        }
    };
}
exports.PatchedElement = PatchedElement;
function PatchedIframeElement(elm) {
    const Ctor = PatchedElement(elm);
    // @ts-ignore type-mismatch
    return class PatchedHTMLIframeElement extends Ctor {
        get contentWindow() {
            const original = dom_1.iFrameContentWindowGetter.call(this);
            if (original) {
                const wrapped = iframe_1.wrapIframeWindow(original);
                return wrapped;
            }
            return original;
        }
    };
}
exports.PatchedIframeElement = PatchedIframeElement;
//# sourceMappingURL=traverse.js.map
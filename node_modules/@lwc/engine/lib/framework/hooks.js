"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const utils_1 = require("./utils");
const vm_1 = require("./vm");
const node_1 = require("../env/node");
const events_1 = __importDefault(require("./modules/events"));
const attrs_1 = __importDefault(require("./modules/attrs"));
const props_1 = __importDefault(require("./modules/props"));
const computed_class_attr_1 = __importDefault(require("./modules/computed-class-attr"));
const computed_style_attr_1 = __importDefault(require("./modules/computed-style-attr"));
const static_class_attr_1 = __importDefault(require("./modules/static-class-attr"));
const static_style_attr_1 = __importDefault(require("./modules/static-style-attr"));
const context_1 = __importDefault(require("./modules/context"));
const patch_1 = require("./patch");
const snabbdom_1 = require("../3rdparty/snabbdom/snabbdom");
const restrictions_1 = require("./restrictions");
const patch_2 = require("./patch");
const def_1 = require("./def");
const noop = () => void 0;
function updateNodeHook(oldVnode, vnode) {
    if (oldVnode.text !== vnode.text) {
        node_1.nodeValueSetter.call(vnode.elm, vnode.text);
    }
}
exports.updateNodeHook = updateNodeHook;
function insertNodeHook(vnode, parentNode, referenceNode) {
    node_1.insertBefore.call(parentNode, vnode.elm, referenceNode);
}
exports.insertNodeHook = insertNodeHook;
function removeNodeHook(vnode, parentNode) {
    node_1.removeChild.call(parentNode, vnode.elm);
}
exports.removeNodeHook = removeNodeHook;
function createTextHook(vnode) {
    const text = vnode.elm;
    const { uid, fallback } = vnode.owner;
    vm_1.setNodeOwnerKey(text, uid);
    if (language_1.isTrue(fallback)) {
        patch_2.patchTextNodeProto(text);
    }
}
exports.createTextHook = createTextHook;
function createCommentHook(vnode) {
    const comment = vnode.elm;
    const { uid, fallback } = vnode.owner;
    vm_1.setNodeOwnerKey(comment, uid);
    if (language_1.isTrue(fallback)) {
        patch_2.patchCommentNodeProto(comment);
    }
}
exports.createCommentHook = createCommentHook;
function createElmDefaultHook(vnode) {
    events_1.default.create(vnode);
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.create(vnode);
    props_1.default.create(vnode);
    static_class_attr_1.default.create(vnode);
    static_style_attr_1.default.create(vnode);
    computed_class_attr_1.default.create(vnode);
    computed_style_attr_1.default.create(vnode);
    context_1.default.create(vnode);
}
exports.createElmDefaultHook = createElmDefaultHook;
var LWCDOMMode;
(function (LWCDOMMode) {
    LWCDOMMode["manual"] = "manual";
})(LWCDOMMode || (LWCDOMMode = {}));
function createElmHook(vnode) {
    const { owner, sel } = vnode;
    const elm = vnode.elm;
    vm_1.setNodeOwnerKey(elm, owner.uid);
    if (language_1.isTrue(owner.fallback)) {
        const { data: { context }, } = vnode;
        const { shadowAttribute } = owner.context;
        const isPortal = !language_1.isUndefined(context) &&
            !language_1.isUndefined(context.lwc) &&
            context.lwc.dom === LWCDOMMode.manual;
        patch_2.patchElementProto(elm, {
            sel,
            isPortal,
            shadowAttribute,
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        const { data: { context }, } = vnode;
        const isPortal = !language_1.isUndefined(context) &&
            !language_1.isUndefined(context.lwc) &&
            context.lwc.dom === LWCDOMMode.manual;
        restrictions_1.patchElementWithRestrictions(elm, { isPortal });
    }
}
exports.createElmHook = createElmHook;
function updateElmDefaultHook(oldVnode, vnode) {
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.update(oldVnode, vnode);
    props_1.default.update(oldVnode, vnode);
    computed_class_attr_1.default.update(oldVnode, vnode);
    computed_style_attr_1.default.update(oldVnode, vnode);
}
exports.updateElmDefaultHook = updateElmDefaultHook;
function insertCustomElmHook(vnode) {
    const vm = vm_1.getCustomElementVM(vnode.elm);
    vm_1.appendVM(vm);
}
exports.insertCustomElmHook = insertCustomElmHook;
function updateChildrenHook(oldVnode, vnode) {
    const { children, owner } = vnode;
    const fn = patch_1.hasDynamicChildren(children) ? snabbdom_1.updateDynamicChildren : snabbdom_1.updateStaticChildren;
    vm_1.runWithBoundaryProtection(owner, owner.owner, noop, () => {
        fn(vnode.elm, oldVnode.children, children);
    }, noop);
}
exports.updateChildrenHook = updateChildrenHook;
function allocateChildrenHook(vnode) {
    const elm = vnode.elm;
    const vm = vm_1.getCustomElementVM(elm);
    const { children } = vnode;
    vm.aChildren = children;
    if (language_1.isTrue(vnode.owner.fallback)) {
        // slow path
        vm_1.allocateInSlot(vm, children);
        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
        vnode.children = utils_1.EmptyArray;
    }
}
exports.allocateChildrenHook = allocateChildrenHook;
function createCustomElmHook(vnode) {
    const elm = vnode.elm;
    if (language_1.hasOwnProperty.call(elm, utils_1.ViewModelReflection)) {
        // There is a possibility that a custom element is registered under tagName,
        // in which case, the initialization is already carry on, and there is nothing else
        // to do here since this hook is called right after invoking `document.createElement`.
        return;
    }
    const { mode, ctor, owner } = vnode;
    const { uid, fallback } = owner;
    vm_1.setNodeOwnerKey(elm, uid);
    const def = def_1.getComponentDef(ctor);
    def_1.setElementProto(elm, def);
    if (language_1.isTrue(fallback)) {
        const { shadowAttribute } = owner.context;
        patch_2.patchCustomElementProto(elm, {
            def,
            shadowAttribute,
        });
    }
    vm_1.createVM(vnode.sel, elm, ctor, {
        mode,
        fallback,
        owner,
    });
    const vm = vm_1.getCustomElementVM(elm);
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);
    }
    if (process.env.NODE_ENV !== 'production') {
        restrictions_1.patchCustomElementWithRestrictions(elm, utils_1.EmptyObject);
    }
}
exports.createCustomElmHook = createCustomElmHook;
function createCustomElmDefaultHook(vnode) {
    events_1.default.create(vnode);
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.create(vnode);
    props_1.default.create(vnode);
    static_class_attr_1.default.create(vnode);
    static_style_attr_1.default.create(vnode);
    computed_class_attr_1.default.create(vnode);
    computed_style_attr_1.default.create(vnode);
    context_1.default.create(vnode);
}
exports.createCustomElmDefaultHook = createCustomElmDefaultHook;
function createChildrenHook(vnode) {
    const { elm, children } = vnode;
    for (let j = 0; j < children.length; ++j) {
        const ch = children[j];
        if (ch != null) {
            ch.hook.create(ch);
            ch.hook.insert(ch, elm, null);
        }
    }
}
exports.createChildrenHook = createChildrenHook;
function rerenderCustomElmHook(vnode) {
    const vm = vm_1.getCustomElementVM(vnode.elm);
    if (process.env.NODE_ENV !== 'production') {
        assert_1.default.isTrue(vm && 'cmpRoot' in vm, `${vm} is not a vm.`);
        assert_1.default.isTrue(language_1.isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);
    }
    vm_1.rerenderVM(vm);
}
exports.rerenderCustomElmHook = rerenderCustomElmHook;
function updateCustomElmDefaultHook(oldVnode, vnode) {
    // Attrs need to be applied to element before props
    // IE11 will wipe out value on radio inputs if value
    // is set before type=radio.
    attrs_1.default.update(oldVnode, vnode);
    props_1.default.update(oldVnode, vnode);
    computed_class_attr_1.default.update(oldVnode, vnode);
    computed_style_attr_1.default.update(oldVnode, vnode);
}
exports.updateCustomElmDefaultHook = updateCustomElmDefaultHook;
function removeElmHook(vnode) {
    // this method only needs to search on child vnodes from template
    // to trigger the remove hook just in case some of those children
    // are custom elements.
    const { children, elm } = vnode;
    for (let j = 0, len = children.length; j < len; ++j) {
        const ch = children[j];
        if (!language_1.isNull(ch)) {
            ch.hook.remove(ch, elm);
        }
    }
}
exports.removeElmHook = removeElmHook;
function removeCustomElmHook(vnode) {
    // for custom elements we don't have to go recursively because the removeVM routine
    // will take care of disconnecting any child VM attached to its shadow as well.
    vm_1.removeVM(vm_1.getCustomElementVM(vnode.elm));
}
exports.removeCustomElmHook = removeCustomElmHook;
//# sourceMappingURL=hooks.js.map
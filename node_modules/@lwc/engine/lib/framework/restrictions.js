"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint no-production-assert: "off" */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const attributes_1 = require("./attributes");
const invoker_1 = require("./invoker");
const vm_1 = require("./vm");
const element_1 = require("../env/element");
function generateDataDescriptor(options) {
    return language_1.assign({
        configurable: true,
        enumerable: true,
        writable: true,
    }, options);
}
function generateAccessorDescriptor(options) {
    return language_1.assign({
        configurable: true,
        enumerable: true,
    }, options);
}
function getNodeRestrictionsDescriptors(node, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    // getPropertyDescriptor here recursively looks up the prototype chain
    // and returns the first descriptor for the property
    const originalTextContentDescriptor = language_1.getPropertyDescriptor(node, 'textContent');
    const originalNodeValueDescriptor = language_1.getPropertyDescriptor(node, 'nodeValue');
    const { appendChild, insertBefore, removeChild, replaceChild } = node;
    return {
        appendChild: generateDataDescriptor({
            value(aChild) {
                if (this instanceof Element && options.isPortal !== true) {
                    assert_1.default.logError(`appendChild is disallowed in Element unless \`lwc:dom="manual"\` directive is used in the template.`, this);
                }
                return appendChild.call(this, aChild);
            },
        }),
        insertBefore: generateDataDescriptor({
            value(newNode, referenceNode) {
                if (this instanceof Element && options.isPortal !== true) {
                    assert_1.default.logError(`insertBefore is disallowed in Element unless \`lwc:dom="manual"\` directive is used in the template.`, this);
                }
                return insertBefore.call(this, newNode, referenceNode);
            },
        }),
        removeChild: generateDataDescriptor({
            value(aChild) {
                if (this instanceof Element && options.isPortal !== true) {
                    assert_1.default.logError(`removeChild is disallowed in Element unless \`lwc:dom="manual"\` directive is used in the template.`, this);
                }
                return removeChild.call(this, aChild);
            },
        }),
        replaceChild: generateDataDescriptor({
            value(newChild, oldChild) {
                if (this instanceof Element && options.isPortal !== true) {
                    assert_1.default.logError(`replaceChild is disallowed in Element unless \`lwc:dom="manual"\` directive is used in the template.`, this);
                }
                return replaceChild.call(this, newChild, oldChild);
            },
        }),
        nodeValue: generateAccessorDescriptor({
            get() {
                return originalNodeValueDescriptor.get.call(this);
            },
            set(value) {
                if (this instanceof Element && options.isPortal !== true) {
                    assert_1.default.logError(`nodeValue is disallowed in Element unless \`lwc:dom="manual"\` directive is used in the template.`, this);
                }
                originalNodeValueDescriptor.set.call(this, value);
            },
        }),
        textContent: generateAccessorDescriptor({
            get() {
                return originalTextContentDescriptor.get.call(this);
            },
            set(value) {
                if (this instanceof Element && options.isPortal !== true) {
                    assert_1.default.logError(`textContent is disallowed in Element unless \`lwc:dom="manual"\` directive is used in the template.`, this);
                }
                originalTextContentDescriptor.set.call(this, value);
            },
        }),
    };
}
function getElementRestrictionsDescriptors(elm, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const descriptors = getNodeRestrictionsDescriptors(elm, options);
    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'innerHTML');
    const originalOuterHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'outerHTML');
    language_1.assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
            get() {
                return originalInnerHTMLDescriptor.get.call(this);
            },
            set(value) {
                if (options.isPortal !== true) {
                    assert_1.default.logError(`innerHTML is disallowed in Element unless \`lwc:dom="manual"\` directive is used in the template.`, this);
                }
                return originalInnerHTMLDescriptor.set.call(this, value);
            },
        }),
        outerHTML: generateAccessorDescriptor({
            get() {
                return originalOuterHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set outerHTML on Element.`);
            },
        }),
    });
    return descriptors;
}
function getShadowRootRestrictionsDescriptors(sr, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    // blacklisting properties in dev mode only to avoid people doing the wrong
    // thing when using the real shadow root, because if that's the case,
    // the component will not work when running in fallback mode.
    const originalQuerySelector = sr.querySelector;
    const originalQuerySelectorAll = sr.querySelectorAll;
    const originalAddEventListener = sr.addEventListener;
    const descriptors = getNodeRestrictionsDescriptors(sr, options);
    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(sr, 'innerHTML');
    const originalTextContentDescriptor = language_1.getPropertyDescriptor(sr, 'textContent');
    language_1.assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
            get() {
                return originalInnerHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);
            },
        }),
        textContent: generateAccessorDescriptor({
            get() {
                return originalTextContentDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);
            },
        }),
        addEventListener: generateDataDescriptor({
            value(type) {
                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${language_1.toString(sr)} by adding an event listener for "${type}".`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalAddEventListener.apply(this, arguments);
            },
        }),
        querySelector: generateDataDescriptor({
            value() {
                const vm = vm_1.getShadowRootVM(this);
                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.template.querySelector() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalQuerySelector.apply(this, arguments);
            },
        }),
        querySelectorAll: generateDataDescriptor({
            value() {
                const vm = vm_1.getShadowRootVM(this);
                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.template.querySelectorAll() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalQuerySelectorAll.apply(this, arguments);
            },
        }),
    });
    const BlackListedShadowRootMethods = {
        appendChild: 0,
        removeChild: 0,
        replaceChild: 0,
        cloneNode: 0,
        insertBefore: 0,
        getElementById: 0,
        getSelection: 0,
        elementsFromPoint: 0,
    };
    language_1.forEach.call(language_1.getOwnPropertyNames(BlackListedShadowRootMethods), (methodName) => {
        const descriptor = generateAccessorDescriptor({
            get() {
                throw new Error(`Disallowed method "${methodName}" in ShadowRoot.`);
            },
        });
        descriptors[methodName] = descriptor;
    });
    return descriptors;
}
// Custom Elements Restrictions:
// -----------------------------
function getAttributePatched(attrName) {
    if (process.env.NODE_ENV !== 'production') {
        const vm = vm_1.getCustomElementVM(this);
        assertAttributeReflectionCapability(vm, attrName);
    }
    return element_1.getAttribute.apply(this, language_1.ArraySlice.call(arguments));
}
function setAttributePatched(attrName, _newValue) {
    const vm = vm_1.getCustomElementVM(this);
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeMutationCapability(vm, attrName);
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.setAttribute.apply(this, language_1.ArraySlice.call(arguments));
}
function setAttributeNSPatched(attrNameSpace, attrName, _newValue) {
    const vm = vm_1.getCustomElementVM(this);
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeMutationCapability(vm, attrName);
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.setAttributeNS.apply(this, language_1.ArraySlice.call(arguments));
}
function removeAttributePatched(attrName) {
    const vm = vm_1.getCustomElementVM(this);
    // marking the set is needed for the AOM polyfill
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeMutationCapability(vm, attrName);
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.removeAttribute.apply(this, language_1.ArraySlice.call(arguments));
}
function removeAttributeNSPatched(attrNameSpace, attrName) {
    const vm = vm_1.getCustomElementVM(this);
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeMutationCapability(vm, attrName);
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.removeAttributeNS.apply(this, language_1.ArraySlice.call(arguments));
}
function assertAttributeReflectionCapability(vm, attrName) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const propName = language_1.isString(attrName)
        ? attributes_1.getPropNameFromAttrName(language_1.StringToLowerCase.call(attrName))
        : null;
    const { elm, def: { props: propsConfig }, } = vm;
    if (!language_1.isUndefined(vm_1.getNodeOwnerKey(elm)) &&
        attributes_1.isAttributeLocked(elm, attrName) &&
        propsConfig &&
        propName &&
        propsConfig[propName]) {
        assert_1.default.logError(`Invalid attribute "${language_1.StringToLowerCase.call(attrName)}" for ${vm}. Instead access the public property with \`element.${propName};\`.`, elm);
    }
}
function assertAttributeMutationCapability(vm, attrName) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const { elm } = vm;
    if (!language_1.isUndefined(vm_1.getNodeOwnerKey(elm)) && attributes_1.isAttributeLocked(elm, attrName)) {
        assert_1.default.logError(`Invalid operation on Element ${vm}. Elements created via a template should not be mutated using DOM APIs. Instead of attempting to update this element directly to change the value of attribute "${attrName}", you can update the state of the component, and let the engine to rehydrate the element accordingly.`, elm);
    }
}
function getCustomElementRestrictionsDescriptors(elm, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const descriptors = getNodeRestrictionsDescriptors(elm, options);
    const originalAddEventListener = elm.addEventListener;
    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'innerHTML');
    const originalOuterHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'outerHTML');
    const originalTextContentDescriptor = language_1.getPropertyDescriptor(elm, 'textContent');
    return language_1.assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
            get() {
                return originalInnerHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);
            },
        }),
        outerHTML: generateAccessorDescriptor({
            get() {
                return originalOuterHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);
            },
        }),
        textContent: generateAccessorDescriptor({
            get() {
                return originalTextContentDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);
            },
        }),
        addEventListener: generateDataDescriptor({
            value(type) {
                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${language_1.toString(elm)} by adding an event listener for "${type}".`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalAddEventListener.apply(this, arguments);
            },
        }),
        // replacing mutators and accessors on the element itself to catch any mutation
        getAttribute: generateDataDescriptor({
            value: getAttributePatched,
        }),
        setAttribute: generateDataDescriptor({
            value: setAttributePatched,
        }),
        setAttributeNS: generateDataDescriptor({
            value: setAttributeNSPatched,
        }),
        removeAttribute: generateDataDescriptor({
            value: removeAttributePatched,
        }),
        removeAttributeNS: generateDataDescriptor({
            value: removeAttributeNSPatched,
        }),
    });
}
function getComponentRestrictionsDescriptors(cmp) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const originalSetAttribute = cmp.setAttribute;
    return {
        setAttribute: generateDataDescriptor({
            value(attrName, _value) {
                // logging errors for experimental and special attributes
                if (language_1.isString(attrName)) {
                    const propName = attributes_1.getPropNameFromAttrName(attrName);
                    const info = attributes_1.getGlobalHTMLPropertiesInfo();
                    if (info[propName] && info[propName].attribute) {
                        const { error, experimental } = info[propName];
                        if (error) {
                            assert_1.default.logError(error, vm_1.getComponentVM(this).elm);
                        }
                        else if (experimental) {
                            assert_1.default.logError(`Attribute \`${attrName}\` is an experimental attribute that is not standardized or supported by all browsers. Property "${propName}" and attribute "${attrName}" are ignored.`, vm_1.getComponentVM(this).elm);
                        }
                    }
                }
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                originalSetAttribute.apply(this, arguments);
            },
            configurable: true,
            enumerable: false,
        }),
        tagName: generateAccessorDescriptor({
            get() {
                throw new Error(`Usage of property \`tagName\` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.`);
            },
            configurable: true,
            enumerable: false,
        }),
    };
}
function getLightingElementProtypeRestrictionsDescriptors(proto) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const info = attributes_1.getGlobalHTMLPropertiesInfo();
    const descriptors = {};
    language_1.forEach.call(language_1.getOwnPropertyNames(info), (propName) => {
        if (propName in proto) {
            return; // no need to redefine something that we are already exposing
        }
        descriptors[propName] = generateAccessorDescriptor({
            get() {
                const { error, attribute, readOnly, experimental } = info[propName];
                const msg = [];
                msg.push(`Accessing the global HTML property "${propName}" in ${this} is disabled.`);
                if (error) {
                    msg.push(error);
                }
                else {
                    if (experimental) {
                        msg.push(`This is an experimental property that is not standardized or supported by all browsers. Property "${propName}" and attribute "${attribute}" are ignored.`);
                    }
                    if (readOnly) {
                        // TODO - need to improve this message
                        msg.push(`Property is read-only.`);
                    }
                    if (attribute) {
                        msg.push(`"Instead access it via the reflective attribute "${attribute}" with one of these techniques:`);
                        msg.push(`  * Use \`this.getAttribute("${attribute}")\` to access the attribute value. This option is best suited for accessing the value in a getter during the rendering process.`);
                        msg.push(`  * Declare \`static observedAttributes = ["${attribute}"]\` and use \`attributeChangedCallback(attrName, oldValue, newValue)\` to get a notification each time the attribute changes. This option is best suited for reactive programming, eg. fetching new data each time the attribute is updated.`);
                    }
                }
                assert_1.default.logWarning(msg.join('\n'), vm_1.getComponentVM(this).elm);
            },
            // a setter is required here to avoid TypeError's when an attribute is set in a template but only the above getter is defined
            set() { },
        });
    });
    return descriptors;
}
function patchNodeWithRestrictions(node, options) {
    language_1.defineProperties(node, getNodeRestrictionsDescriptors(node, options));
}
exports.patchNodeWithRestrictions = patchNodeWithRestrictions;
function patchElementWithRestrictions(elm, options) {
    language_1.defineProperties(elm, getElementRestrictionsDescriptors(elm, options));
}
exports.patchElementWithRestrictions = patchElementWithRestrictions;
// This routine will prevent access to certain properties on a shadow root instance to guarantee
// that all components will work fine in IE11 and other browsers without shadow dom support.
function patchShadowRootWithRestrictions(sr, options) {
    language_1.defineProperties(sr, getShadowRootRestrictionsDescriptors(sr, options));
}
exports.patchShadowRootWithRestrictions = patchShadowRootWithRestrictions;
function patchCustomElementWithRestrictions(elm, options) {
    const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm, options);
    const elmProto = language_1.getPrototypeOf(elm);
    language_1.setPrototypeOf(elm, language_1.create(elmProto, restrictionsDescriptors));
}
exports.patchCustomElementWithRestrictions = patchCustomElementWithRestrictions;
function patchComponentWithRestrictions(cmp) {
    language_1.defineProperties(cmp, getComponentRestrictionsDescriptors(cmp));
}
exports.patchComponentWithRestrictions = patchComponentWithRestrictions;
function patchLightningElementPrototypeWithRestrictions(proto) {
    language_1.defineProperties(proto, getLightingElementProtypeRestrictionsDescriptors(proto));
}
exports.patchLightningElementPrototypeWithRestrictions = patchLightningElementPrototypeWithRestrictions;
//# sourceMappingURL=restrictions.js.map
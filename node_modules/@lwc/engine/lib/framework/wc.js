"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const language_1 = require("../shared/language");
const vm_1 = require("./vm");
const utils_1 = require("./utils");
const def_1 = require("./def");
const element_1 = require("../env/element");
const dom_1 = require("../env/dom");
const attributes_1 = require("./attributes");
const patch_1 = require("./patch");
const restrictions_1 = require("./restrictions");
function buildCustomElementConstructor(Ctor, options) {
    var _a;
    const { props, bridge: BaseElement } = def_1.getComponentDef(Ctor);
    const normalizedOptions = {
        fallback: false,
        mode: 'open',
        isRoot: true,
        owner: null,
    };
    if (language_1.isObject(options) && !language_1.isNull(options)) {
        const { mode, fallback } = options;
        // TODO: for now, we default to open, but eventually it should default to 'closed'
        if (mode === 'closed') {
            normalizedOptions.mode = mode;
        }
        // fallback defaults to false to favor shadowRoot
        normalizedOptions.fallback = language_1.isTrue(fallback) || language_1.isFalse(dom_1.isNativeShadowRootAvailable);
    }
    return _a = class extends BaseElement {
            constructor() {
                super();
                const tagName = language_1.StringToLowerCase.call(element_1.tagNameGetter.call(this));
                if (language_1.isTrue(normalizedOptions.fallback)) {
                    const def = def_1.getComponentDef(Ctor);
                    patch_1.patchCustomElementProto(this, {
                        def,
                    });
                }
                vm_1.createVM(tagName, this, Ctor, normalizedOptions);
                if (process.env.NODE_ENV !== 'production') {
                    restrictions_1.patchCustomElementWithRestrictions(this, utils_1.EmptyObject);
                }
            }
            connectedCallback() {
                const vm = vm_1.getCustomElementVM(this);
                vm_1.appendRootVM(vm);
            }
            disconnectedCallback() {
                const vm = vm_1.getCustomElementVM(this);
                vm_1.removeRootVM(vm);
            }
            attributeChangedCallback(attrName, oldValue, newValue) {
                if (oldValue === newValue) {
                    // ignoring similar values for better perf
                    return;
                }
                const propName = attributes_1.getPropNameFromAttrName(attrName);
                if (language_1.isUndefined(props[propName])) {
                    // ignoring unknown attributes
                    return;
                }
                if (!attributes_1.isAttributeLocked(this, attrName)) {
                    // ignoring changes triggered by the engine itself during:
                    // * diffing when public props are attempting to reflect to the DOM
                    // * component via `this.setAttribute()`, should never update the prop.
                    // Both cases, the the setAttribute call is always wrap by the unlocking
                    // of the attribute to be changed
                    return;
                }
                // reflect attribute change to the corresponding props when changed
                // from outside.
                this[propName] = newValue;
            }
        },
        // collecting all attribute names from all public props to apply
        // the reflection from attributes to props via attributeChangedCallback.
        _a.observedAttributes = language_1.ArrayMap.call(language_1.getOwnPropertyNames(props), propName => props[propName].attr),
        _a;
}
exports.buildCustomElementConstructor = buildCustomElementConstructor;
//# sourceMappingURL=wc.js.map
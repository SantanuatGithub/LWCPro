"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const language_1 = require("../../shared/language");
const node_1 = require("../../faux-shadow/node");
const shadow_root_1 = require("../../faux-shadow/shadow-root");
const OriginalMutationObserver = window.MutationObserver;
const { disconnect: originalDisconnect, observe: originalObserve, takeRecords: originalTakeRecords, } = OriginalMutationObserver.prototype;
// Internal fields to maintain relationships
const observedTargetsField = '$$lwcObservedTargets$$';
const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
/**
 * Retarget the mutation record's target value to its shadowRoot
 * @param {MutationRecord} originalRecord
 */
function retargetMutationRecord(originalRecord) {
    const { addedNodes, removedNodes, target, type } = originalRecord;
    const retargetedRecord = language_1.create(MutationRecord.prototype);
    language_1.defineProperties(retargetedRecord, {
        addedNodes: {
            get() {
                return addedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        removedNodes: {
            get() {
                return removedNodes;
            },
            enumerable: true,
            configurable: true,
        },
        type: {
            get() {
                return type;
            },
            enumerable: true,
            configurable: true,
        },
        target: {
            get() {
                return target.shadowRoot;
            },
            enumerable: true,
            configurable: true,
        },
    });
    return retargetedRecord;
}
/**
 * This function first gathers the OwnerKey of all the targets observed by the MutationObserver instance.
 * Next, process each MutationRecord to determine if the mutation occured in the same shadow tree as
 * one of the targets being observed.
 *
 * The key filtering logic is to match the observed target node's ownerKey/ownKey with the ownerKey of the nodes in the
 * MutationRecord.
 * The ownerKey of the rootnode will be undefined. Similarly ownerkey of nodes outside the shadow will be undefined.
 * @param {MutationRecords[]} mutations
 * @param {MutationObserver} observer
 */
function filterMutationRecords(mutations, observer) {
    const observedTargets = observer[observedTargetsField];
    const observedTargetOwnerKeys = [];
    language_1.forEach.call(observedTargets, (node) => {
        // If the observed target is a shadowRoot, the ownerkey of the shadow tree will be fetched using the host
        const observedTargetOwnerKey = node instanceof window.ShadowRoot
            ? node_1.getNodeKey(node.host)
            : node_1.getNodeNearestOwnerKey(node);
        language_1.ArrayPush.call(observedTargetOwnerKeys, observedTargetOwnerKey);
    });
    return language_1.ArrayReduce.call(mutations, (filteredSet, record) => {
        const { target, addedNodes, removedNodes, type } = record;
        // If the mutations affected a lwc host element or its shadow,
        // because LWC uses synthetic shadow, target will be the host
        if (type === 'childList' && !language_1.isUndefined(node_1.getNodeKey(target))) {
            // Optimization: Peek in and test one node to decide if the MutationRecord qualifies
            // The remaining nodes in this MutationRecord will have the same ownerKey
            const sampleNode = addedNodes.length > 0 ? addedNodes[0] : removedNodes[0];
            const sampleNodeOwnerKey = node_1.getNodeNearestOwnerKey(sampleNode);
            // Is node being added/removed to a subtree that is being observed
            if (language_1.ArrayIndexOf.call(observedTargetOwnerKeys, sampleNodeOwnerKey) !== -1) {
                // If the target was being observed, then return record as-is
                if (observedTargets.indexOf(target) !== -1) {
                    language_1.ArrayPush.call(filteredSet, record);
                }
                else {
                    // else, must be observing the shadowRoot
                    language_1.ArrayPush.call(filteredSet, retargetMutationRecord(record));
                }
            }
        }
        else {
            // if target is shadowRoot, then fetch key of shadow tree from the host
            // this should never be the case when synthetic shadow is on, only when running in native
            const recordTargetOwnerKey = target instanceof window.ShadowRoot
                ? node_1.getNodeKey(target.host)
                : node_1.getNodeNearestOwnerKey(target);
            const mutationInScope = language_1.ArrayIndexOf.call(observedTargetOwnerKeys, recordTargetOwnerKey) !== -1;
            if (mutationInScope) {
                language_1.ArrayPush.call(filteredSet, record);
            }
        }
        return filteredSet;
    }, []);
}
function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];
    if (language_1.isUndefined(wrappedCallback)) {
        wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
            // Filter mutation records
            const filteredRecords = filterMutationRecords(mutations, observer);
            // If not records are eligible for the observer, do not invoke callback
            if (filteredRecords.length === 0) {
                return;
            }
            callback.call(observer, filteredRecords, observer);
        };
    }
    return wrappedCallback;
}
/**
 * Patched MutationObserver constructor.
 * 1. Wrap the callback to filter out MutationRecords based on dom ownership
 * 2. Add a property field to track all observed targets of the observer instance
 * @param {MutationCallback} callback
 */
function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer = new OriginalMutationObserver(wrappedCallback);
    language_1.defineProperty(observer, observedTargetsField, { value: [] });
    return observer;
}
function patchedDisconnect() {
    if (!language_1.isUndefined(this[observedTargetsField])) {
        this[observedTargetsField].length = 0;
    }
    originalDisconnect.call(this);
}
/**
 * A single mutation observer can observe multiple nodes(target).
 * Maintain a list of all targets that the observer chooses to observe
 * @param {Node} target
 * @param {Object} options
 */
function patchedObserve(target, options) {
    // If the observer was created by the patched constructor, this field should be defined. Adding a guard for extra safety
    if (!language_1.isUndefined(this[observedTargetsField])) {
        language_1.ArrayPush.call(this[observedTargetsField], target);
    }
    // If the target is a SyntheticShadowRoot, observe the host since the shadowRoot is an empty documentFragment
    if (target instanceof shadow_root_1.SyntheticShadowRoot) {
        target = target.host;
    }
    return originalObserve.call(this, target, options);
}
/**
 * Patch the takeRecords() api to filter MutationRecords based on the observed targets
 */
function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
}
function apply() {
    window.MutationObserver = PatchedMutationObserver;
    window.MutationObserver.prototype = OriginalMutationObserver.prototype;
    window.MutationObserver.prototype.disconnect = patchedDisconnect;
    window.MutationObserver.prototype.observe = patchedObserve;
    window.MutationObserver.prototype.takeRecords = patchedTakeRecords;
}
exports.default = apply;
//# sourceMappingURL=polyfill.js.map
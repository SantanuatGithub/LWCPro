"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/* eslint-env node */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const node_modules_paths_1 = __importDefault(require("./node-modules-paths"));
const DEFAULT_IGNORE = ['**/node_modules/**', '**/__tests__/**'];
const PACKAGE_PATTERN = `**/*/package.json`;
const MODULE_ENTRY_PATTERN = `**/*.[jt]s`;
const LWC_CONFIG_FILE = '.lwcrc';
function createRegistryEntry(entry, moduleSpecifier, moduleName, moduleNamespace) {
    return { entry, moduleSpecifier, moduleName, moduleNamespace };
}
function loadLwcConfig(modulePath) {
    const packageJsonPath = path_1.default.join(modulePath, 'package.json');
    const lwcConfigPath = path_1.default.join(modulePath, LWC_CONFIG_FILE);
    let config;
    try {
        const jsonPkg = require(packageJsonPath);
        try {
            config = fs_1.default.readFileSync(lwcConfigPath, 'utf8');
        }
        catch (e) {
            config = jsonPkg.lwc;
        }
    }
    catch (ignore) {
        // ignore
    }
    return config;
}
function resolveModulesInDir(absPath) {
    return glob_1.default.sync(MODULE_ENTRY_PATTERN, { cwd: absPath }).reduce((mappings, file) => {
        const ext = path_1.default.extname(file);
        const fileName = path_1.default.basename(file, ext);
        const rootDir = path_1.default.dirname(file);
        const rootParts = rootDir.split('/'); // the glob library normalizes paths to forward slashes only - https://github.com/isaacs/node-glob#windows
        const entry = path_1.default.join(absPath, file);
        const dirModuleName = rootParts.pop();
        const dirModuleNamespace = rootParts.pop();
        if (dirModuleNamespace && dirModuleName === fileName) {
            const registryNode = createRegistryEntry(entry, `${dirModuleNamespace}/${fileName}`, fileName, dirModuleNamespace.toLowerCase());
            mappings[registryNode.moduleSpecifier] = registryNode;
        }
        return mappings;
    }, {});
}
exports.resolveModulesInDir = resolveModulesInDir;
function hasModuleBeenVisited(module, visited) {
    if (visited.has(module)) {
        /* eslint-disable-next-line no-console */
        console.log(`Package ${module} already resolved`);
        return true;
    }
    return false;
}
function expandModuleDirectories({ moduleDirectories, rootDir, } = {}) {
    if (!moduleDirectories && !rootDir) {
        return module.paths;
    }
    return node_modules_paths_1.default(rootDir || __dirname, moduleDirectories);
}
function resolveModules(modules, opts) {
    if (Array.isArray(modules)) {
        modules.forEach(modulePath => resolveModules(modulePath, opts));
    }
    else {
        const { mappings, visited, moduleRoot } = opts;
        if (typeof modules === 'string') {
            const packageEntries = resolveModulesInDir(path_1.default.join(moduleRoot, modules));
            Object.keys(packageEntries).forEach(moduleName => {
                if (!hasModuleBeenVisited(moduleName, visited)) {
                    mappings[moduleName] = packageEntries[moduleName];
                    visited.add(moduleName);
                }
            });
        }
        else {
            Object.keys(modules).forEach(moduleName => {
                if (!hasModuleBeenVisited(moduleName, visited)) {
                    const modulePath = path_1.default.join(moduleRoot, modules[moduleName]);
                    mappings[moduleName] = { moduleSpecifier: moduleName, entry: modulePath };
                    visited.add(moduleName);
                }
            });
        }
    }
}
function resolveLwcNpmModules(options = {}) {
    const visited = new Set();
    const modulePaths = expandModuleDirectories(options);
    return modulePaths.reduce((m, nodeModulesDir) => {
        return glob_1.default
            .sync(PACKAGE_PATTERN, { cwd: nodeModulesDir, ignore: DEFAULT_IGNORE })
            .reduce((mappings, file) => {
            const moduleRoot = path_1.default.dirname(path_1.default.join(nodeModulesDir, file));
            const lwcConfig = loadLwcConfig(moduleRoot);
            if (lwcConfig) {
                resolveModules(lwcConfig.modules, { mappings, visited, moduleRoot, lwcConfig });
            }
            return mappings;
        }, m);
    }, {});
}
exports.resolveLwcNpmModules = resolveLwcNpmModules;
//# sourceMappingURL=index.js.map